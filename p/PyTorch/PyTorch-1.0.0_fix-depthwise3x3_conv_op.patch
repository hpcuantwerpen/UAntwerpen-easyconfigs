# Fixes pytorch-1.0.0/caffe2/share/contrib/depthwise/depthwise3x3_conv_op.cc
# This file uses __builtin_shuffle (GCC-only) or __builtin_shufflevector (Clang-only)
# without providing an alternative implementation for compilers that don't support
# this feature. The patch provides two alternative implementations, a generic one
# and one using AVX intrinsics that are supported by Intel, GCC and Clang
# Developed by Kurt Lust (VSC/UAntwerp)
--- pytorch-1.0.0.orig/caffe2/share/contrib/depthwise/depthwise3x3_conv_op.cc	2019-01-09 15:26:32.589204000 +0100
+++ pytorch-1.0.0/caffe2/share/contrib/depthwise/depthwise3x3_conv_op.cc	2019-01-18 17:00:18.170386632 +0100
@@ -239,7 +239,65 @@
   return (psimd_f32){c, c, c, c};
 }
 
-#if defined(__clang__)
+
+#if defined(USE_AVX) || defined(USE_AVX2)
+
+/* Note that as the tests are structured now, this implementation with intrinsics
+   will be used instead of __builtin_shuffle(vector) also with Clang and GCC... */
+
+PSIMD_INTRINSIC psimd_f32 psimd_interleave_lo_f32(psimd_f32 a, psimd_f32 b) {
+    /* return (psimd_f32){a[0], b[0], a[1], b[1]}; */
+    const __m128i mask = _mm_setr_epi32( 0, 2, 1, 3 );
+    __m128 tmp = _mm_shuffle_ps( (__m128) a, (__m128) b, (unsigned int) 0x44 );
+    return (psimd_f32) _mm_permutevar_ps( tmp, (__m128i) mask );
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_interleave_hi_f32(psimd_f32 a, psimd_f32 b) {
+    /* return (psimd_f32){a[2], b[2], a[3], b[3]}; */
+    const __m128i mask = _mm_setr_epi32( 0, 2, 1, 3 );
+    __m128 tmp = _mm_shuffle_ps( (__m128) a, (__m128) b, (unsigned int) 0xEE );
+    return (psimd_f32) _mm_permutevar_ps( tmp, (__m128i) mask );
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_concat_lo_f32(psimd_f32 a, psimd_f32 b) {
+    /* return (psimd_f32){a[0], a[1], b[0], b[1]}; */
+    return (psimd_f32) _mm_shuffle_ps( (__m128) a, (__m128) b, (unsigned int) 0x44 );
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_concat_hi_f32(psimd_f32 a, psimd_f32 b) {
+    /* return (psimd_f32){a[2], a[3], b[2], b[3]}; */
+    return (psimd_f32) _mm_shuffle_ps( (__m128) a, (__m128) b, (unsigned int) 0xEE );
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_shift_f32(psimd_f32 a) {
+    /* return (psimd_f32){a[1], a[2], a[3], a[3]}; */
+    const __m128i mask = _mm_setr_epi32( 1, 2, 3, 3 );
+    return (psimd_f32) _mm_permutevar_ps( (__m128) a, mask );
+}
+
+#elif defined(__ICC)  || defined(__ICL)
+
+PSIMD_INTRINSIC psimd_f32 psimd_interleave_lo_f32(psimd_f32 a, psimd_f32 b) {
+  return (psimd_f32){a[0], b[0], a[1], b[1]};
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_interleave_hi_f32(psimd_f32 a, psimd_f32 b) {
+  return (psimd_f32){a[2], b[2], a[3], b[3]};
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_concat_lo_f32(psimd_f32 a, psimd_f32 b) {
+  return (psimd_f32){a[0], a[1], b[0], b[1]};
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_concat_hi_f32(psimd_f32 a, psimd_f32 b) {
+  return (psimd_f32){a[2], a[3], b[2], b[3]};
+}
+
+PSIMD_INTRINSIC psimd_f32 psimd_shift_f32(psimd_f32 a) {
+    return (psimd_f32){a[1], a[2], a[3], a[3]};
+}
+
+#elif defined(__clang__)
 
 PSIMD_INTRINSIC psimd_f32 psimd_interleave_lo_f32(psimd_f32 a, psimd_f32 b) {
   return __builtin_shufflevector(a, b, 0, 4 + 0, 1, 4 + 1);
@@ -257,6 +315,10 @@
   return __builtin_shufflevector(a, b, 2, 3, 4 + 2, 4 + 3);
 }
 
+PSIMD_INTRINSIC psimd_f32 psimd_shift_f32(psimd_f32 a) {
+  return __builtin_shufflevector(a, a, 1, 2, 3, -1 );
+}
+
 #else
 
 PSIMD_INTRINSIC psimd_f32 psimd_interleave_lo_f32(psimd_f32 a, psimd_f32 b) {
@@ -274,6 +336,10 @@
   return __builtin_shuffle(a, b, (psimd_s32){2, 3, 4 + 2, 4 + 3});
 }
 
+PSIMD_INTRINSIC psimd_f32 psimd_shift_f32(psimd_f32 a) {
+  return __builtin_shuffle(a, (psimd_s32){1, 2, 3, -1});
+}
+
 #endif
 
 static inline void psimd_transpose4x4_f32(
@@ -347,12 +413,7 @@
   const psimd_f32 g0 = psimd_load_f32(kernel);
   const psimd_f32 g1 = psimd_load_f32(kernel + 3);
   const psimd_f32 g5678 = psimd_load_f32(kernel + 5);
-#ifdef __clang__
-  const psimd_f32 g2 = __builtin_shufflevector(g5678, g5678, 1, 2, 3, -1);
-#else
-  const psimd_f32 g2 =
-      __builtin_shuffle(g5678, g5678, (psimd_s32){1, 2, 3, -1});
-#endif
+  const psimd_f32 g2 = psimd_shift_f32(g5678);
   psimd_f32 w[4];
   winograd_f2k3_kernel_transform(g0, g1, g2, &w[0], &w[1], &w[2], &w[3]);
   psimd_transpose4x4_f32(w[0], w[1], w[2], w[3], &w[0], &w[1], &w[2], &w[3]);
